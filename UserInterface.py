import tkinter as tk
from tkinter import messagebox

# Author: Emanuel Iulian Gheorghe
# Project: A*GO - Professional Practice Week 2
# Module: CET313


# variable declaration
# uncommented declarations indicate would have indication in their name
Width = 30
(x, y) = (20, 16)  # grid dimensions
player = (1, 7)  # coordinates for initial player position

# load the coordinates generated by the A* algorithm
with open("path-coord.txt") as f:
    coords = [tuple(map(float, i.split(','))) for i in f]

# initializing coordinates for the walls in the maze
walls = [
    (1, 15),
    (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7), (2, 8), (2, 10), (2, 12), (2, 13), (2, 15), (2, 17), (2, 18),
    (3, 2), (3, 6), (3, 10), (3, 13),
    (4, 2), (4, 4), (4, 6), (4, 8), (4, 9), (4, 10), (4, 11), (4, 12), (4, 13), (4, 14), (4, 15), (4, 16), (4, 17),
    (5, 4), (5, 6), (5, 17),
    (6, 1), (6, 2), (6, 3), (6, 4), (6, 6), (6, 7), (6, 8), (6, 9), (6, 10), (6, 11), (6, 12), (6, 13), (6, 14),
    (6, 15), (6, 17),
    (7, 2), (7, 10), (7, 17),
    (8, 2), (8, 3), (8, 4), (8, 5), (8, 6), (8, 7), (8, 8), (8, 10), (8, 11), (8, 13), (8, 15), (8, 16), (8, 17),
    (9, 2), (9, 8), (9, 10), (9, 11), (9, 12), (9, 13), (9, 15), (9, 17),
    (10, 4), (10, 5), (10, 6), (10, 8), (10, 13), (10, 15),
    (11, 1), (11, 2), (11, 3), (11, 4), (11, 6), (11, 8), (11, 9), (11, 10), (11, 11), (11, 12), (11, 13), (11, 15),
    (11, 6), (11, 17),
    (12, 6), (12, 11), (12, 17),
    (13, 2), (13, 3), (13, 4), (13, 5), (13, 6), (13, 7), (13, 8), (13, 11), (13, 12), (13, 13), (13, 14), (13, 15),
    (13, 17),
    (14, 17),
    (15, 1), (15, 2), (15, 3), (15, 4), (15, 5), (15, 6), (15, 7), (15, 8), (15, 9), (15, 10), (15, 11), (15, 12),
    (15, 13), (15, 14), (15, 15), (15, 16), (15, 17), (15, 18)
]

# setting special attributes for start and end cells
specials = [(1, 7, "yellow", 1), (18, 13, "green", 1)]

# variable that would hold the coordinates of specials
specialcoords = []

# variable that would hold the generated path coordinates
path_coordinates = []


class Game(tk.Tk):

    # defining initializing function
    def __init__(self):
        tk.Tk.__init__(self)
        self.can = tk.Canvas(self, width=x * Width,
                             height=y * Width)  # variable holding a reference of the gui's canvas widget
        self.can.pack(fill="both", expand=False)
        self.render_grid()
        self.resizable(False, False)
        self.title("A-Star GO Prototype by Emanuel Gheorghe")
        self.maxsize(604, 484)

        # create the rectangle that would be controlled by the player
        self.player = self.can.create_rectangle(player[0] * Width + Width * 2 / 10, player[1] * Width + Width * 2 / 10,
                                                player[0] * Width + Width * 8 / 10, player[1] * Width + Width * 8 / 10,
                                                fill="red", width=1)
        # player's start coordinates
        self.x = 1
        self.y = 7
        self.endx = 13
        self.endy = 18
        self.bind("<Key>", self.move_player)
        self.generateMaze()
        self.resize(104)
        # messagebox.showinfo("Some tips before you go on", "Welcome!\nBefore you start, some advice:\nPRESS SPACEBAR
        # to see clues on the path towards the EXIT!\nLucky you, you have unlimited clues!")

    # the function will resize the window based on the player's position
    def resize(self, w):
        h = 484
        self.geometry(f"{w}x{h}")

    # as the name suggests, this function is rendering the grid on the canvas
    def render_grid(self):
        global specials, walls, Width, x, y
        for i in range(x):
            for j in range(y):
                self.can.create_rectangle(i * Width, j * Width, (i + 1) * Width, (j + 1) * Width, fill="white", width=1)
                if (i == 0 or j == 0) or i == 19:
                    walls.append((j, i))
        for (j, i) in walls:
            self.can.create_rectangle(i * Width, j * Width, (i + 1) * Width, (j + 1) * Width, fill="black", width=1)
        for (i, j, c, w) in specials:
            specialcoords.append((j, i))
            self.can.create_rectangle(i * Width, j * Width, (i + 1) * Width, (j + 1) * Width, fill=c, width=1)
        self.initialize_path()
        self.hide_path()

    # this function is the equivalent of self.sleep() but it would not stop running processes when called
    def waithere(self):
        var = tk.IntVar()
        self.after(3000, var.set, 1)
        self.wait_variable(var)

    # this function takes a system event such as a key press,
    # and based on the what key is being pressed,
    # it would move the player to that direction if the move is valid
    def move_player(self, event):
        margin_right = 3
        key = event.keysym
        if key == "Left":
            self.x = self.x - 1
            if self.isValidMove():
                self.can.move(self.player, -30, 0)
            else:
                self.x = self.x + 1
        elif key == "Right":
            self.x = self.x + 1
            if self.isValidMove():
                self.can.move(self.player, 30, 0)
                if self.x % margin_right == 0:
                    self.resize(self.winfo_width() + 100)
                    margin_right = margin_right * 2
            else:
                self.x = self.x - 1
        elif key == "Up":
            self.y = self.y - 1
            if self.isValidMove():
                self.can.move(self.player, 0, -30)
            else:
                self.y = self.y + 1
        elif key == "Down":
            self.y = self.y + 1
            if self.isValidMove():
                self.can.move(self.player, 0, 30)
            else:
                self.y = self.y - 1
            if self.x == 18 and self.y == 13:
                messagebox.showinfo("Congratulations! You WON", "YOU WON!\nYou reached the end of The Maze!")
        elif key == "space":
            self.display_path()
            self.waithere()
            self.hide_path()

    # this function is converting the path coordinates to graphical representation
    def initialize_path(self):
        for (j, i) in coords:
            temp = self.can.create_rectangle(i * Width, j * Width, (i + 1) * Width, (j + 1) * Width, fill="purple",
                                             width=1)
            path_coordinates.append(temp)

    # as the name suggests, the function is displaying the generated path
    def display_path(self):
        for temp in path_coordinates:
            self.can.itemconfig(temp, fill='purple')

    # this function is hiding the generated path
    def hide_path(self):
        for temp in path_coordinates:
            self.can.itemconfig(temp, fill='white')

    # this function is checking if the cell that the player was about to move towards is a wall
    def isValidMove(self):
        if (self.y, self.x) in walls:
            return False
        return True

    # this function is converting the current graphical representation
    # of the maze into a representation familiar to the current A* pathfinding algorithm
    def generateMaze(self):
        maze = ""
        for i in range(y):
            for j in range(x):
                if (i, j) == (self.endx, self.endy):
                    maze = maze + "x"
                elif (i, j) == (self.y, self.x):
                    maze = maze + "o"
                elif (i, j) in walls:
                    maze = maze + "#"
                else:
                    maze = maze + " "
            maze = maze + "\n"
        f = open("maze-map.txt", "w")
        f.write(maze)


if __name__ == '__main__':
    game = Game()

    game.mainloop()
